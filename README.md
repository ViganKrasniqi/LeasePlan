# Waarkoop herokuapp

The app contains several product which we can access them by sending request at the API



## The starter project
#### Requirements 
```shell
• Refactor the given project

• Make it run correctly on Gitlab CI

• Use BDD format: Cucumber/Gherkin

• Required framework: Java Serenity + Maven
```
The Project was build using Java11, Maven 3.8.6 with selenium and serenity.

#### Execution

```shell
mvn clean install
```
### The project directory structure
The project has build scripts for both Maven and follows the standard directory structure used in most Serenity projects:
```Gherkin
src
  + main
   + java
    + starter                     Responses Class
    + utility                     Unit layer
  + test
    + java                        Test runners and supporting code
     + starter
      + stepdefinitions           SearchStepDefinitions class
    + resources
      + features                  Feature files
       + search                  Feature file subdirectories 
target
performance                       Performance Tests  
  
.gitignore
pom.xml
README.md
serenity.properties  
  

```


## The sample scenario
Both variations of the sample project uses the sample Cucumber scenario. In this scenario, we want to make a get the products from store and check 
for their information.
```Gherkin
Feature: Search for the product

  Scenario Outline: Check for the endpoint response for different products
    When he calls endpoint "https://waarkoop-server.herokuapp.com/api/v1/search/demo/<product>"
    Then he should get the 200 status code
    Then he sees the results displayed for product
```
Code Sample
```Java
@When("he calls endpoint {string}")
public void heCallsEndpoint(String url) {
responses.getProductModel(url);
}

@Then("he sees the results displayed for product")
public void heSeesTheResultsDisplayedForProduct() {

ProductModel[] tempProductList = new GsonBuilder().create().fromJson(SerenityRest.lastResponse().body().prettyPrint(), ProductModel[].class);
productModelList = Arrays.asList(tempProductList);
Assert.assertTrue(productModelList.stream().allMatch(ProductModel::CheckALlNullValues));
}

@Then("he should get the {int} status code")
public void heShouldGetTheStatusCode(int arg0) {
restAssuredThat(response -> response.statusCode(arg0));
}

@Then("he doesn't see the results of {string}")
public void heDoesnTSeeTheResultsOf(String missing_product) {

productErrorModel = new GsonBuilder().create().fromJson(SerenityRest.lastResponse().body().prettyPrint(), ProductErrorModel.class);
Assert.assertTrue(Detail.validateProperErrorStructure(productErrorModel.getDetail(), missing_product));
}
```
_heCallsEndpoint(String url):_ This method simulates a user calling an API endpoint with the provided URL using the "responses" object. It initiates a request to the given endpoint.

_heSeesTheResultsDisplayedForProduct()_: This method parses the response body from the last API call and converts it into an array of ProductModel objects. It then checks if all the ProductModel objects have non-null values, ensuring the correctness of data.

_heShouldGetTheStatusCode(int arg0)_: This method asserts that the HTTP status code of the response matches the provided integer value. It uses the "restAssuredThat" function to perform this assertion.

_heDoesnTSeeTheResultsOf(String missing_product)_: This method parses the response body from the last API call and converts it into a ProductErrorModel object. It validates that the error structure in the "detail" field of the ProductErrorModel matches the expected structure for the given missing product.

## Executing the tests
To run the sample project, you can either just run the `CucumberTestSuite` test runner class, or run either `mvn verify` from the command line.

By default, the tests will run using Chrome. You can run them in Firefox by overriding the `driver` system property, e.g.
```json
$ mvn clean verify -Ddriver=firefox
```


The test results will be recorded in the `target/site/serenity` directory.

## Executing performance tests
To run the PerformanceTest.jmx we would need to jMeter.

In our case we used jMeter 5.6.2 in order to create the performance tests.

We used 3 thread groups and the first one is about load test and the other 2 about spike test.

## Generating the reports
Since the Serenity reports contain aggregate information about all of the tests, they are not generated after each individual test (as this would be extremenly inefficient). Rather, The Full Serenity reports are generated by the `serenity-maven-plugin`. You can trigger this by running `mvn serenity:aggregate` from the command line or from your IDE.

The reports are also integrated into the Maven build process: the following code in the `pom.xml` file causes the reports to be generated automatically once all the tests have completed when you run `mvn verify`

```
             <plugin>
                <groupId>net.serenity-bdd.maven.plugins</groupId>
                <artifactId>serenity-maven-plugin</artifactId>
                <version>${serenity.maven.version}</version>
                <configuration>
                    <tags>${tags}</tags>
                </configuration>
                <executions>
                    <execution>
                        <id>serenity-reports</id>
                        <phase>post-integration-test</phase>
                        <goals>
                            <goal>aggregate</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
```


##Want to Learn More?
##### Expand your knowledge of Serenity BDD and related topics by exploring these resources:

_Serenity BDD Book: Dive into the official online documentation source, the Serenity BDD Book, to gain a comprehensive understanding of Serenity BDD's concepts and usage._

https://serenity-bdd.github.io/theserenitybook/latest/index.html

_Maven Documentation: Explore the official Maven documentation to learn how to manage your project's build lifecycle and dependencies efficiently._

https://maven.apache.org/guides/index.html

_Java Documentation: Delve into Oracle's official documentation to deepen your understanding of the Java programming language._

https://docs.oracle.com/en/java/

_Test Automation Best Practices: Discover essential test automation best practices to ensure effective and reliable automated testing._

https://www.softwaretestinghelp.com/test-automation-best-practices/

_Serenity BDD Blog: Access a collection of regularly updated articles about Serenity BDD by industry expert John Ferguson Smart. Gain insights, tips, and practical advice on leveraging Serenity BDD effectively._

https://johnfergusonsmart.com/category/serenity-bdd/

